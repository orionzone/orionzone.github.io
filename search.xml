<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第2章 对象</title>
      <link href="/2020/06/10/%E7%AC%AC2%E7%AB%A0%20%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/06/10/%E7%AC%AC2%E7%AB%A0%20%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="2-2-基本数据类型"><a href="#2-2-基本数据类型" class="headerlink" title="2.2 基本数据类型"></a>2.2 基本数据类型</h2><p><strong>string不是基本数据类型。</strong><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623035617955-09b38f57-74af-41fc-b77f-c1eed0108a24.png#align=left&display=inline&height=375&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=1464&size=353596&status=done&style=none&width=732" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></p><h3 id="2-2-2-高精度数字"><a href="#2-2-2-高精度数字" class="headerlink" title="2.2.2 高精度数字"></a>2.2.2 高精度数字</h3><ul><li><strong>高精度数字：BigInteger、BigDecimal</strong><ul><li><strong>BigInteger：支持任意精度的整数。</strong></li><li><strong>BigDecimal：支持任意精度的定点数。</strong><h3 id="2-2-3-创建数组对象就是创建一个引用数组。"><a href="#2-2-3-创建数组对象就是创建一个引用数组。" class="headerlink" title="2.2.3 创建数组对象就是创建一个引用数组。"></a>2.2.3 创建数组对象就是创建一个引用数组。</h3><h2 id="2-3-生命周期"><a href="#2-3-生命周期" class="headerlink" title="2.3 生命周期"></a>2.3 生命周期</h2></li></ul></li></ul><p><strong>java对象生命周期和基本类型不一样。用new创建的对象可以存活于作用域之外。</strong><br><strong>java垃圾回收器会监视new的对象，辨别不会再被引用的对象并释放内存空间。</strong></p><h2 id="2-4-初始值"><a href="#2-4-初始值" class="headerlink" title="2.4 初始值"></a>2.4 初始值</h2><p><strong>变量作为类的成员或全局变量会有初始默认值，局部变量没有初始值。</strong><br><strong><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623047121378-883d8c64-5647-4638-881b-d8f810f42bfd.png#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&name=image.png&originHeight=606&originWidth=814&size=143850&status=done&style=none&width=407" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></strong></p><h2 id="2-5-java函数可以返回数组，c-c-不能"><a href="#2-5-java函数可以返回数组，c-c-不能" class="headerlink" title="2.5 java函数可以返回数组，c/c++不能"></a>2.5 java函数可以返回数组，c/c++不能</h2><h2 id="2-6-java库函数-java-util"><a href="#2-6-java库函数-java-util" class="headerlink" title="2.6 java库函数 java.util.*"></a>2.6 java库函数 <code>java.util.*</code></h2><h3 id="2-6-3-static-关键字"><a href="#2-6-3-static-关键字" class="headerlink" title="2.6.3 static 关键字"></a>2.6.3 static 关键字</h3><ul><li><strong>static适用于两种情况</strong><ul><li><strong>分配单一存储空间，不考虑创建多少对象或者不创建对象。</strong></li><li><strong>创建的方法不与包含它的类的对象关联起来</strong></li></ul></li><li><strong>创建static事物后，即使没有创建对象也可以调用static方法或static域。</strong></li></ul><p><strong><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623048101090-70ad2664-3a0b-43da-a079-9c1871587658.png#align=left&display=inline&height=245&margin=%5Bobject%20Object%5D&name=image.png&originHeight=490&originWidth=2324&size=276817&status=done&style=none&width=1162" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></strong></p><ul><li><strong>static变量或static方法可以通过类名直接引用，而且是首选方式</strong> <strong>。</strong></li><li><strong>static方法内部不能调用非static方法，非static方法可以调用static方法</strong> <strong>。</strong></li></ul><p>**</p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 操作符</title>
      <link href="/2020/06/10/%E7%AC%AC3%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2020/06/10/%E7%AC%AC3%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="3-2-和equals"><a href="#3-2-和equals" class="headerlink" title="3.2 ==和equals"></a>3.2 ==和equals</h2><ul><li><p><strong>==的含义：</strong></p><ul><li>**比较基本数据类型的值是否相同。 **</li><li><strong>比较引用数据类型的地址是否相同。</strong></li></ul></li><li><p><strong>equals的含义：</strong></p><ul><li><strong>Object中的equals和==一样，都是比较对象的地址。</strong></li><li><strong>String在Object的基础上重写了equals，比较的是字符串的内容。</strong></li></ul></li><li><p><strong>String的equals源码</strong><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623050363973-3db728b6-ccbd-4f46-b2c2-869916add925.png#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1016&originWidth=1432&size=111870&status=done&style=none&width=716" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"> </p><h2 id="3-15-类型转换"><a href="#3-15-类型转换" class="headerlink" title="3.15 类型转换"></a>3.15 类型转换</h2></li><li><p><strong>编译器会在必要的时候自动将int转换到long。</strong></p></li><li><p><strong>小数据类型会自动转换为大数据类型。</strong></p><ul><li><strong>如：char、byte、short在运算时会自动转换为int。</strong></li></ul></li><li><p><strong>大数据类型到小数据类型需要强制转换。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 控制执行流程</title>
      <link href="/2020/06/10/%E7%AC%AC4%E7%AB%A0%20%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/06/10/%E7%AC%AC4%E7%AB%A0%20%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="4-4-foreach与for循环"><a href="#4-4-foreach与for循环" class="headerlink" title="4.4 foreach与for循环"></a>4.4 foreach与for循环</h2><ul><li><strong>foreach和for循环在数组遍历上，速度相当，for循环稍快。</strong></li><li><strong>在链表遍历上，foreach比for循环快很多。</strong></li><li><strong>foreach不能插入和删除操作。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 初始化与清理</title>
      <link href="/2020/06/10/%E7%AC%AC5%E7%AB%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/"/>
      <url>/2020/06/10/%E7%AC%AC5%E7%AB%A0%20%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-构造器"><a href="#5-1-构造器" class="headerlink" title="5.1 构造器"></a>5.1 构造器</h2><p><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623066243814-c5164378-184c-4332-b847-6bdc72e4dbdb.png#align=left&display=inline&height=144&id=EJXx0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=1054&size=65614&status=done&style=none&width=527" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></p><h2 id="5-2-重载"><a href="#5-2-重载" class="headerlink" title="5.2 重载"></a>5.2 重载</h2><ul><li><strong>重载方法必须拥有独一无二的参数列表，返回值不同不能作为区分重载的标志。</strong></li><li><strong>传入数据类型小于方法中的参数类型，会自动提升。如果没有char类型，会自动提升到int型。</strong></li><li><strong>传入数据类型大于方法中的参数类型，必须强制转换。</strong></li></ul><blockquote><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ul><li><strong>重载：在同一个类中相同名字的方法，参数列表不同。</strong></li><li><strong>重写：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了。</strong></li></ul></blockquote><h2 id="5-3-默认构造器"><a href="#5-3-默认构造器" class="headerlink" title="5.3 默认构造器"></a>5.3 默认构造器</h2><ul><li><p><strong>没有写构造器会自动创建无参构造器。</strong></p></li><li><p><strong>写了构造器，就不会自动创建构造器。</strong></p><h2 id="5-4-this关键字"><a href="#5-4-this关键字" class="headerlink" title="5.4 this关键字"></a>5.4 this关键字</h2></li><li><p><strong>在方法内部使用，表示调用该方法的那个对象的引用。</strong></p></li><li><p><strong>在方法中调用同一个类的另一个方法不需要用this，只有当需要明确指出对当前对象的引用时才用this。</strong></p><ul><li><strong>例如return this 或者作为参数传递给外部函数。</strong></li></ul></li><li><p><strong>在构造器中使用this调用另一个构造器。</strong></p><h2 id="5-7-初始化顺序"><a href="#5-7-初始化顺序" class="headerlink" title="5.7 初始化顺序"></a>5.7 初始化顺序</h2></li><li><p><strong>静态变量（只初始化一次）-》非静态变量-》构造器</strong></p><h2 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组初始化三种形式</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-8-1-可变参数列表"><a href="#5-8-1-可变参数列表" class="headerlink" title="5.8.1 可变参数列表"></a>5.8.1 可变参数列表</h3></li><li><p><strong>用Object数组或Object… args作为参数即可。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 访问权限控制</title>
      <link href="/2020/06/10/%E7%AC%AC6%E7%AB%A0%20%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/06/10/%E7%AC%AC6%E7%AB%A0%20%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623114705209-dcccd671-5cba-4ea4-bf16-e12503a774ef.png#align=left&display=inline&height=122&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=555&size=48643&status=done&style=none&width=555" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></p><ul><li><strong>public：可以被所有其他类所访问。</strong></li><li><strong>private：只能被自己访问和修改。</strong></li><li><strong>protected：自身、子类及同一个包中类可以访问。</strong></li><li><strong>default：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。</strong></li><li><strong>为了继承，通常把数据指定为private，方法为public</strong> <strong>。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 复用类</title>
      <link href="/2020/06/10/%E7%AC%AC7%E7%AB%A0%20%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
      <url>/2020/06/10/%E7%AC%AC7%E7%AB%A0%20%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-当需要String时，编译器会自动调用toString"><a href="#7-1-当需要String时，编译器会自动调用toString" class="headerlink" title="7.1 当需要String时，编译器会自动调用toString()"></a>7.1 <strong>当需要String时，编译器会自动调用toString()</strong></h2><p><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623159329626-a19f780c-dffd-4804-9569-7a19daad3038.png#align=left&display=inline&height=582&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1164&originWidth=1244&size=457230&status=done&style=none&width=622" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></p><h2 id="7-2-导出类构造器和基类构造器"><a href="#7-2-导出类构造器和基类构造器" class="headerlink" title="7.2 导出类构造器和基类构造器"></a>7.2 导出类构造器和基类构造器</h2><p><strong>所有的类都可以含有main方法，无需删除，方便单元测试。</strong></p><ul><li><strong>创建从基类继承的类的对象会先执行基类构造器，然后再执行继承类的构造器<strong><strong>，所以导出类构造器中必须带有基类构造器</strong></strong>。</strong><ul><li><strong>若想要在继承类中调用基类的带参数的构造器，需要使用super关键字****。</strong></li><li><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623142147010-a770367b-5db0-4cc3-8ba8-1949ca6bff8f.png#align=left&display=inline&height=294&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=948&size=130017&status=done&style=none&width=474" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"><h2 id="7-6-protected-关键字"><a href="#7-6-protected-关键字" class="headerlink" title="7.6 protected 关键字"></a>7.6 protected 关键字</h2><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623139693203-a58aa111-e5d6-4488-bc57-645dacde8812.png#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&name=image.png&originHeight=174&originWidth=2336&size=209371&status=done&style=none&width=2336" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"><h2 id="7-7-向上转型"><a href="#7-7-向上转型" class="headerlink" title="7.7 向上转型"></a>7.7 向上转型</h2></li></ul></li></ul><p><strong>导出类对象自动提升到基类对象，向上转型是安全的，只会丢失方法。</strong><br><strong><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623142107300-2de0a306-9651-4c26-a56d-1cf22447798a.png#align=left&display=inline&height=428&margin=%5Bobject%20Object%5D&name=image.png&originHeight=856&originWidth=1196&size=250265&status=done&style=none&width=598" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></strong><br>**</p><h3 id="7-7-2-再论继承与组合"><a href="#7-7-2-再论继承与组合" class="headerlink" title="7.7.2 再论继承与组合"></a>7.7.2 再论继承与组合</h3><p><strong>使用继承还是组合最清晰的办法就是要不要向上转型。如果要向上转型，那继承是必要的。如果不需要，再好好考虑</strong> <strong>。</strong></p><h2 id="7-8-final关键字"><a href="#7-8-final关键字" class="headerlink" title="7.8 final关键字"></a>7.8 final关键字</h2><h3 id="7-8-1-final-数据"><a href="#7-8-1-final-数据" class="headerlink" title="7.8.1 final 数据"></a>7.8.1 final 数据</h3><ul><li><p><strong>若是基本数据类型则值不变</strong> 。</p></li><li><p><strong>若是对象引用则引用不变，一旦被初始化，则无法再指向另一个对象，对象自身可以修改</strong> <strong>。</strong></p></li><li><p><strong>既是static又是final的变量用大写表示。</strong></p><h3 id="final-参数"><a href="#final-参数" class="headerlink" title="final 参数"></a>final 参数</h3></li><li><p><strong>方法的参数列表指定为final。基本数据类型值不能修改，引用对象不能更换指向。</strong></p><h3 id="7-8-2-final-方法"><a href="#7-8-2-final-方法" class="headerlink" title="7.8.2 final 方法"></a>7.8.2 final 方法</h3></li><li><p><strong>final方法不能重写</strong> <strong>。</strong></p></li><li><p><strong>private方法已经隐式的指定为final，不能重写。</strong></p></li><li><p>final方法可以关闭动态绑定 。</p><h3 id="7-8-3-final-类"><a href="#7-8-3-final-类" class="headerlink" title="7.8.3 final 类"></a>7.8.3 final 类</h3></li><li><p><strong>final类不能继承</strong> <strong>。</strong></p></li><li><p>final类中的变量可以选择final或者不final，但是方法不能重写 。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章 多态</title>
      <link href="/2020/06/10/%E7%AC%AC8%E7%AB%A0%20%E5%A4%9A%E6%80%81/"/>
      <url>/2020/06/10/%E7%AC%AC8%E7%AB%A0%20%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="8-2-绑定"><a href="#8-2-绑定" class="headerlink" title="8.2 绑定"></a>8.2 绑定</h2><p><strong>静态绑定和动态绑定</strong></p><ul><li><strong>绑定：一个方法的调用与方法所在的类关联起来。</strong></li><li><strong>静态绑定：在编译过程中就已经知道这个方法到底是哪个类中的方法。</strong></li><li>**动态绑定：运行时根据对象的类进行绑定。 **</li></ul><p><strong>java中除了static和final方法（包括private），其他方法都是动态绑定</strong> <strong>。</strong></p><h3 id="8-2-1-向上转型"><a href="#8-2-1-向上转型" class="headerlink" title="8.2.1 向上转型"></a>8.2.1 向上转型</h3><p>**<img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623199931095-60b950f7-52a6-4ec5-8056-d3d9bb81779a.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&name=image.png&originHeight=888&originWidth=1786&size=272991&status=done&style=none&width=893" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png">    **<strong>s.draw()调用的是circle的draw()</strong></p><ul><li><strong>多态 = 向上转型 = 动态绑定 。</strong><ul><li><strong>静态方法不具有多态性</strong> 。<img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623202962000-df4a13e5-18a3-430d-826a-996f0a7610e4.png#align=left&display=inline&height=655&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1310&originWidth=1414&size=485170&status=done&style=none&width=707" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"><h2 id="8-3-带main方法的类构造器继承调用顺序"><a href="#8-3-带main方法的类构造器继承调用顺序" class="headerlink" title="8.3 带main方法的类构造器继承调用顺序"></a>8.3 带main方法的类构造器继承调用顺序</h2><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623203395334-adbb21d4-9f71-4134-bc9f-f13e60ef80de.png#align=left&display=inline&height=168&margin=%5Bobject%20Object%5D&name=image.png&originHeight=336&originWidth=2338&size=260105&status=done&style=none&width=1169" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"><br><img "" class="lazyload placeholder" data-original="https://cdn.nlark.com/yuque/0/2021/png/21769923/1623203537087-5748e290-37d3-4fce-bc6b-30ecd0d37763.png#align=left&display=inline&height=632&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1264&originWidth=956&size=323529&status=done&style=none&width=478" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image.png"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 接口</title>
      <link href="/2020/06/10/%E7%AC%AC9%E7%AB%A0%20%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/06/10/%E7%AC%AC9%E7%AB%A0%20%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="9-1-抽象类和抽象方法"><a href="#9-1-抽象类和抽象方法" class="headerlink" title="9.1 抽象类和抽象方法"></a>9.1 抽象类和抽象方法</h2><p><strong>含有抽象方法的类叫做抽象类</strong> <strong>。</strong><br><strong><code>abstract class name&#123;...``&#125;</code></strong></p><h3 id="抽象方法的特征"><a href="#抽象方法的特征" class="headerlink" title="抽象方法的特征"></a>抽象方法的特征</h3><ul><li><strong>抽象方法不允许有方法体，只能以分号“;”结尾</strong> 。</li><li>**抽象方法只能声明在抽象类中 **<strong>。</strong></li><li>**抽象类中可以包含0个或多个抽象方法。 **</li><li><strong>抽象方法必须被子类实现</strong> 。</li><li>**如果子类不能实现父类中的抽象方法，那么子类也必须是抽象类 ** 。<h3 id="什么情况下使用抽象方法和抽象类"><a href="#什么情况下使用抽象方法和抽象类" class="headerlink" title="什么情况下使用抽象方法和抽象类"></a>什么情况下使用抽象方法和抽象类</h3></li></ul><p><strong>父类的名称比较抽象，创建对象无意义。</strong></p><h2 id="9-2-接口"><a href="#9-2-接口" class="headerlink" title="9.2 接口"></a>9.2 接口</h2><p><strong>比抽象类更抽象。</strong><br><strong><code>interface A&#123;...&#125;</code></strong><br><strong><code>class B implements A&#123;...&#125;</code></strong><br><strong>接口中的变量隐式的指定为static和final</strong> ， <strong>没有方法体 。</strong></p><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul><li><strong>抽象类只能单继承,接口能多实现</strong> 。</li><li><strong>抽象类是一个类,可以被任意权限修饰符修饰,静态和非静态属性，final和非final属性，可以有抽象方法和非抽象方法</strong></li><li><strong>接口只能被public,final修饰,只能有静态方法,即使没有显示的声明，而且是不可修改的；</strong></li><li><strong>抽象类是对类的抽象，接口是对行为的抽象。</strong></li><li><strong>设计抽象类是自下而上的过程,我子类需要,所以我定义抽象类；而设计接口是自上而下的过程,我接口规范某一行为,我某类需要这个行为,我实现某接口；</strong></li></ul><p><strong>核心区别:</strong><br><strong>调用者使用动机不同,实现接口是为了使用他规范的某一个行为；</strong><br><strong>继承抽象类是为了使用这个类属性和行为.</strong></p><p><strong>再简单点说:</strong><br><strong>我们知道 *<em><strong>抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧</strong> <strong>！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”</strong><a href="https://link.zhihu.com/?target=http://www.mydown.com/soft/network/chat/475/444475.shtml"><strong>is</strong></a></em>*-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的规则而已。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 导论</title>
      <link href="/2020/06/08/%E7%AC%AC1%E7%AB%A0%20%E5%AF%BC%E8%AE%BA/"/>
      <url>/2020/06/08/%E7%AC%AC1%E7%AB%A0%20%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<div class="video"><video controls preload><source src='https://assets.mixkit.co/videos/preview/mixkit-down-the-river-in-a-bamboo-canoe-6804-large.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><p><strong>每一个对象在内存中都有一个唯一的地址，new的对象在堆中。</strong></p><h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h2><p><strong>高内聚、低耦合：模块之间紧密联系，并且保持独立性。</strong></p><h2 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h2><ul><li><strong>public、private、protected</strong><ul><li><strong>private: 除类型创建者和类型的内部方法之外的任何人都不能访问。</strong></li><li><strong>protected：与 private作用相当，差别仅在于继承的类可以访问 protected成员，但是不能访问private成员。</strong><div class="video"><video controls preload><source src='https://assets.mixkit.co/videos/preview/mixkit-down-the-river-in-a-bamboo-canoe-6804-large.mp4' type='video/mp4'>Your browser does not support the video tag.</video></div><h2 id="1-5-组合"><a href="#1-5-组合" class="headerlink" title="1.5 组合"></a>1.5 组合</h2></li></ul></li><li>**组合：由类的对象组合成新类。 **<ul><li><strong>has-a（拥有）关系的时候用组合</strong> <strong>。</strong></li><li><strong>新类的成员对象通常都被声明为 private，使得可以在不干扰现有客户端代码的情况下，修改这些成员，也可以在运行时修改这些成员对象，以实现动态修改程序的行为。</strong></li><li><strong>通常用于在新类中使用现有类的功能而非接口的情况，即在新类中嵌入现有类的private对象</strong> <strong>。</strong></li></ul></li></ul><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6 继承"></a>1.6 继承</h2><p><strong>is-a（是一个）或者like-a（像是一个）的时候用继承</strong> <strong>。</strong><br><strong>有两种方法可以使基类与导出类产生差异：extends关键字、覆盖基类的方法。</strong><br><strong>判断用组合还是继承，先看看要不要向上转型</strong> 。</p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p><strong>所有类继承于Object。</strong><br><strong>所有对象都在堆上创建（new）。</strong></p><h2 id="1-10-生命周期"><a href="#1-10-生命周期" class="headerlink" title="1.10 生命周期"></a>1.10 生命周期</h2><ul><li><strong>java完全采用动态内存分配方式。</strong><ul><li>**在堆栈上创建对象，编译器可以确定对象存活时间，自动销毁。但是在堆上创建对象，编译器对其生命周期一无所知。</li></ul></li></ul><p>**</p>]]></content>
      
      
      <categories>
          
          <category> java编程思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
